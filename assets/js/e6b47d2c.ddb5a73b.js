(self.webpackChunkckb_sdk=self.webpackChunkckb_sdk||[]).push([[872],{9410:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return l},metadata:function(){return o},toc:function(){return c},default:function(){return p}});var i=n(2122),s=n(9756),r=(n(7294),n(3905)),a=["components"],l={id:"demo",title:"Demo"},o={unversionedId:"javasdk/demo",id:"javasdk/demo",isDocsHomePage:!1,title:"Demo",description:"Get the Block Chain Information",source:"@site/docs/javasdk/demo.md",sourceDirName:"javasdk",slug:"/javasdk/demo",permalink:"/ckb_sdk/docs/javasdk/demo",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/javasdk/demo.md",version:"current",frontMatter:{id:"demo",title:"Demo"}},c=[{value:"Get the Block Chain Information",id:"get-the-block-chain-information",children:[]},{value:"Get the Current Block Number",id:"get-the-current-block-number",children:[]},{value:"Get the Current Block Information",id:"get-the-current-block-information",children:[]},{value:"DAO Operations",id:"dao-operations",children:[]},{value:"Transfer CKB to a Multisig Address",id:"transfer-ckb-to-a-multisig-address",children:[]},{value:"Transfer CKB to Multiple Receivers",id:"transfer-ckb-to-multiple-receivers",children:[]},{value:"Transfer all Balance",id:"transfer-all-balance",children:[]}],d={toc:c};function p(e){var t=e.components,n=(0,s.Z)(e,a);return(0,r.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"get-the-block-chain-information"},"Get the Block Chain Information"),(0,r.kt)("h2",{id:"get-the-current-block-number"},"Get the Current Block Number"),(0,r.kt)("h2",{id:"get-the-current-block-information"},"Get the Current Block Information"),(0,r.kt)("h2",{id:"dao-operations"},"DAO Operations"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="ckb-sdk-java/example/src/main/java/org/nervos/ckb/NervosDaoExample.java"',title:'"ckb-sdk-java/example/src/main/java/org/nervos/ckb/NervosDaoExample.java"'},'package org.nervos.ckb;\n\nimport static org.nervos.ckb.utils.Const.*;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport org.nervos.ckb.crypto.secp256k1.Sign;\nimport org.nervos.ckb.indexer.*;\nimport org.nervos.ckb.service.Api;\nimport org.nervos.ckb.system.SystemContract;\nimport org.nervos.ckb.system.type.SystemScriptCell;\nimport org.nervos.ckb.transaction.*;\nimport org.nervos.ckb.type.Block;\nimport org.nervos.ckb.type.OutPoint;\nimport org.nervos.ckb.type.Script;\nimport org.nervos.ckb.type.Witness;\nimport org.nervos.ckb.type.cell.CellDep;\nimport org.nervos.ckb.type.cell.CellInput;\nimport org.nervos.ckb.type.cell.CellOutput;\nimport org.nervos.ckb.type.cell.CellWithStatus;\nimport org.nervos.ckb.type.fixed.UInt64;\nimport org.nervos.ckb.type.transaction.Transaction;\nimport org.nervos.ckb.type.transaction.TransactionWithStatus;\nimport org.nervos.ckb.utils.EpochUtils;\nimport org.nervos.ckb.utils.Numeric;\nimport org.nervos.ckb.utils.Utils;\n\n/** Copyright \xa9 2019 Nervos Foundation. All rights reserved. */\npublic class NervosDaoExample {\n  private static final String NERVOS_DAO_DATA = "0x0000000000000000";\n  private static final int DAO_LOCK_PERIOD_EPOCHS = 180;\n  private static final int DAO_MATURITY_BLOCKS = 5;\n\n  private static Api api;\n  private static CkbIndexerApi ckbIndexerApi;\n  private static String DaoTestPrivateKey =\n      "08730a367dfabcadb805d69e0e613558d5160eb8bab9d6e326980c2c46a05db2";\n  private static String DaoTestAddress = "ckt1qyqxgp7za7dajm5wzjkye52asc8fxvvqy9eqlhp82g";\n\n  private static final String DEPOSIT = "deposit";\n  private static final String WITHDRAW_PHASE1 = "withdraw";\n  private static final String WITHDRAW_PHASE2 = "claim";\n\n  static {\n    api = new Api(NODE_URL, false);\n    ckbIndexerApi = new CkbIndexerApi(CKB_INDEXER_URL, false);\n  }\n\n  public static void main(String[] args) throws Exception {\n    if (args.length > 0) {\n      if (DEPOSIT.equals(args[0])) {\n        System.out.println("Before depositing, balance: " + getBalance(DaoTestAddress) + " CKB");\n        Transaction transaction = generateDepositingToDaoTx(Utils.ckbToShannon(1000));\n        String txHash = api.sendTransaction(transaction);\n        System.out.println("Nervos DAO deposit tx hash: " + txHash);\n        // Waiting some time to make tx into blockchain\n        System.out.println("After depositing, balance: " + getBalance(DaoTestAddress) + " CKB");\n      } else if (WITHDRAW_PHASE1.equals(args[0])) {\n        // Nervos DAO withdraw phase1 must be after 4 epoch of depositing transaction\n        String depositTxHash = args[1];\n        OutPoint depositOutPoint = new OutPoint(depositTxHash, "0x0");\n        Transaction transaction = generateWithdrawingFromDaoTx(depositOutPoint);\n        String txHash = api.sendTransaction(transaction);\n        System.out.println("Nervos DAO withdraw phase1 tx hash: " + txHash);\n      } else if (WITHDRAW_PHASE2.equals(args[0])) {\n        // Nervos DAO withdraw phase2 must be after 180 epoch of depositing transaction\n        String withdrawTxHash = args[1];\n        TransactionWithStatus withdrawTx = api.getTransaction(withdrawTxHash);\n        OutPoint depositOutPoint = withdrawTx.transaction.inputs.get(0).previousOutput;\n        OutPoint withdrawOutPoint = new OutPoint(withdrawTxHash, "0x0");\n        Transaction transaction =\n            generateClaimingFromDaoTx(depositOutPoint, withdrawOutPoint, Utils.ckbToShannon(0.01));\n        String txHash = api.sendTransaction(transaction);\n        System.out.println("Nervos DAO withdraw phase2 tx hash: " + txHash);\n        // Waiting some time to make tx into blockchain\n        System.out.println("After withdrawing, balance: " + getBalance(DaoTestAddress) + " CKB");\n      }\n    }\n  }\n\n  private static String getBalance(String address) throws IOException {\n    return new IndexerCollector(api, ckbIndexerApi)\n        .getCapacity(address)\n        .divide(UnitCKB)\n        .toString(10);\n  }\n\n  private static Transaction generateDepositingToDaoTx(BigInteger capacity) throws IOException {\n    Script type =\n        new Script(SystemContract.getSystemNervosDaoCell(api).cellHash, "0x", Script.TYPE);\n\n    IndexerCollector txUtils = new IndexerCollector(api, ckbIndexerApi);\n\n    List<CellOutput> cellOutputs =\n        txUtils.generateOutputs(\n            Collections.singletonList(new Receiver(DaoTestAddress, capacity)), DaoTestAddress);\n    cellOutputs.get(0).type = type;\n\n    List<String> cellOutputsData = Arrays.asList(NERVOS_DAO_DATA, "0x");\n\n    List<ScriptGroupWithPrivateKeys> scriptGroupWithPrivateKeysList = new ArrayList<>();\n    TransactionBuilder txBuilder = new TransactionBuilder(api);\n    txBuilder.addOutputs(cellOutputs);\n    txBuilder.setOutputsData(cellOutputsData);\n    txBuilder.addCellDep(\n        new CellDep(SystemContract.getSystemNervosDaoCell(api).outPoint, CellDep.CODE));\n\n    // You can get fee rate by rpc or set a simple number\n    BigInteger feeRate = BigInteger.valueOf(1024);\n    IndexerCollector indexerCollector = new IndexerCollector(api, ckbIndexerApi);\n    CollectResult collectResult =\n        indexerCollector.collectInputs(\n            Collections.singletonList(DaoTestAddress),\n            txBuilder.buildTx(),\n            feeRate,\n            Sign.SIGN_LENGTH * 2);\n\n    // update change output capacity after collecting cells\n    cellOutputs.get(cellOutputs.size() - 1).capacity = collectResult.changeCapacity;\n    txBuilder.setOutputs(cellOutputs);\n\n    int startIndex = 0;\n    for (CellsWithAddress cellsWithAddress : collectResult.cellsWithAddresses) {\n      txBuilder.addInputs(cellsWithAddress.inputs);\n      for (int i = 0; i < cellsWithAddress.inputs.size(); i++) {\n        txBuilder.addWitness(i == 0 ? new Witness(Witness.SIGNATURE_PLACEHOLDER) : "0x");\n      }\n      scriptGroupWithPrivateKeysList.add(\n          new ScriptGroupWithPrivateKeys(\n              new ScriptGroup(NumberUtils.regionToList(startIndex, cellsWithAddress.inputs.size())),\n              Collections.singletonList(DaoTestPrivateKey)));\n      startIndex += cellsWithAddress.inputs.size();\n    }\n\n    Secp256k1SighashAllBuilder signBuilder = new Secp256k1SighashAllBuilder(txBuilder.buildTx());\n\n    for (ScriptGroupWithPrivateKeys scriptGroupWithPrivateKeys : scriptGroupWithPrivateKeysList) {\n      signBuilder.sign(\n          scriptGroupWithPrivateKeys.scriptGroup, scriptGroupWithPrivateKeys.privateKeys.get(0));\n    }\n    return signBuilder.buildTx();\n  }\n\n  private static Transaction generateWithdrawingFromDaoTx(OutPoint depositOutPoint)\n      throws IOException {\n    CellWithStatus cellWithStatus = api.getLiveCell(depositOutPoint, true);\n    if (!CellWithStatus.Status.LIVE.getValue().equals(cellWithStatus.status)) {\n      throw new IOException("Cell is not yet live!");\n    }\n    TransactionWithStatus transactionWithStatus = api.getTransaction(depositOutPoint.txHash);\n    if (!TransactionWithStatus.Status.COMMITTED\n        .getValue()\n        .equals(transactionWithStatus.txStatus.status)) {\n      throw new IOException("Transaction is not committed yet!");\n    }\n    Block depositBlock = api.getBlock(transactionWithStatus.txStatus.blockHash);\n    BigInteger depositBlockNumber = Numeric.toBigInt(depositBlock.header.number);\n    CellOutput cellOutput = cellWithStatus.cell.output;\n\n    String outputData = Numeric.toHexString(new UInt64(depositBlockNumber).toBytes());\n\n    Script lock = LockUtils.generateLockScriptWithAddress(DaoTestAddress);\n    CellOutput changeOutput = new CellOutput("0x0", lock);\n\n    List<CellOutput> cellOutputs = Arrays.asList(cellOutput, changeOutput);\n    List<String> cellOutputsData = Arrays.asList(outputData, "0x");\n    List<String> headerDeps = Collections.singletonList(depositBlock.header.hash);\n\n    List<ScriptGroupWithPrivateKeys> scriptGroupWithPrivateKeysList = new ArrayList<>();\n    TransactionBuilder txBuilder = new TransactionBuilder(api);\n    txBuilder.addCellDep(\n        new CellDep(SystemContract.getSystemNervosDaoCell(api).outPoint, CellDep.CODE));\n    txBuilder.setOutputsData(cellOutputsData);\n    txBuilder.setHeaderDeps(headerDeps);\n    txBuilder.addOutputs(cellOutputs);\n    txBuilder.addInput(new CellInput(depositOutPoint, "0x0"));\n\n    // You can get fee rate by rpc or set a simple number\n    BigInteger feeRate = BigInteger.valueOf(1024);\n    IndexerCollector indexerCollector = new IndexerCollector(api, ckbIndexerApi);\n    CollectResult collectResult =\n        indexerCollector.collectInputs(\n            Collections.singletonList(DaoTestAddress),\n            txBuilder.buildTx(),\n            feeRate,\n            Sign.SIGN_LENGTH * 2);\n\n    // update change output capacity after collecting cells\n    cellOutputs.get(cellOutputs.size() - 1).capacity = collectResult.changeCapacity;\n    txBuilder.setOutputs(cellOutputs);\n\n    CellsWithAddress cellsWithAddress = collectResult.cellsWithAddresses.get(0);\n    txBuilder.setInputs(cellsWithAddress.inputs);\n    for (int i = 0; i < cellsWithAddress.inputs.size(); i++) {\n      if (i == 0) {\n        txBuilder.addWitness(new Witness(Witness.SIGNATURE_PLACEHOLDER));\n      } else {\n        txBuilder.addWitness("0x");\n      }\n    }\n    ScriptGroup scriptGroup =\n        new ScriptGroup(NumberUtils.regionToList(0, cellsWithAddress.inputs.size()));\n    scriptGroupWithPrivateKeysList.add(\n        new ScriptGroupWithPrivateKeys(scriptGroup, Collections.singletonList(DaoTestPrivateKey)));\n\n    Secp256k1SighashAllBuilder signBuilder = new Secp256k1SighashAllBuilder(txBuilder.buildTx());\n\n    for (ScriptGroupWithPrivateKeys scriptGroupWithPrivateKeys : scriptGroupWithPrivateKeysList) {\n      signBuilder.sign(\n          scriptGroupWithPrivateKeys.scriptGroup, scriptGroupWithPrivateKeys.privateKeys.get(0));\n    }\n    return signBuilder.buildTx();\n  }\n\n  private static Transaction generateClaimingFromDaoTx(\n      OutPoint depositOutPoint, OutPoint withdrawingOutPoint, BigInteger fee) throws IOException {\n    Script lock = LockUtils.generateLockScriptWithAddress(DaoTestAddress);\n    CellWithStatus cellWithStatus = api.getLiveCell(withdrawingOutPoint, true);\n    if (!CellWithStatus.Status.LIVE.getValue().equals(cellWithStatus.status)) {\n      throw new IOException("Cell is not yet live!");\n    }\n    TransactionWithStatus transactionWithStatus = api.getTransaction(withdrawingOutPoint.txHash);\n    if (!TransactionWithStatus.Status.COMMITTED\n        .getValue()\n        .equals(transactionWithStatus.txStatus.status)) {\n      throw new IOException("Transaction is not committed yet!");\n    }\n\n    BigInteger depositBlockNumber =\n        new UInt64(Numeric.hexStringToByteArray(cellWithStatus.cell.data.content)).getValue();\n    Block depositBlock = api.getBlockByNumber(Numeric.toHexStringWithPrefix(depositBlockNumber));\n    EpochUtils.EpochInfo depositEpoch = EpochUtils.parse(depositBlock.header.epoch);\n\n    Block withdrawBlock = api.getBlock(transactionWithStatus.txStatus.blockHash);\n    EpochUtils.EpochInfo withdrawEpoch = EpochUtils.parse(withdrawBlock.header.epoch);\n\n    long withdrawFraction = withdrawEpoch.index * depositEpoch.length;\n    long depositFraction = depositEpoch.index * withdrawEpoch.length;\n    long depositedEpochs = withdrawEpoch.number - depositEpoch.number;\n    if (withdrawFraction > depositFraction) {\n      depositedEpochs += 1;\n    }\n    long lockEpochs =\n        (depositedEpochs + (DAO_LOCK_PERIOD_EPOCHS - 1))\n            / DAO_LOCK_PERIOD_EPOCHS\n            * DAO_LOCK_PERIOD_EPOCHS;\n    long minimalSinceEpochNumber = depositEpoch.number + lockEpochs;\n    long minimalSinceEpochIndex = depositEpoch.index;\n    long minimalSinceEpochLength = depositEpoch.length;\n\n    String minimalSince =\n        EpochUtils.generateSince(\n            minimalSinceEpochLength, minimalSinceEpochIndex, minimalSinceEpochNumber);\n    String outputCapacity =\n        api.calculateDaoMaximumWithdraw(depositOutPoint, withdrawBlock.header.hash);\n\n    CellOutput cellOutput =\n        new CellOutput(\n            Numeric.toHexStringWithPrefix(Numeric.toBigInt(outputCapacity).subtract(fee)), lock);\n\n    SystemScriptCell secpCell = SystemContract.getSystemSecpCell(api);\n    SystemScriptCell nervosDaoCell = SystemContract.getSystemNervosDaoCell(api);\n\n    Transaction tx =\n        new Transaction(\n            "0x0",\n            Arrays.asList(\n                new CellDep(secpCell.outPoint, CellDep.DEP_GROUP),\n                new CellDep(nervosDaoCell.outPoint)),\n            Arrays.asList(depositBlock.header.hash, withdrawBlock.header.hash),\n            Collections.singletonList(new CellInput(withdrawingOutPoint, minimalSince)),\n            Collections.singletonList(cellOutput),\n            Collections.singletonList("0x"),\n            Collections.singletonList(new Witness("", NERVOS_DAO_DATA, "")));\n\n    return tx.sign(Numeric.toBigInt(DaoTestPrivateKey));\n  }\n}\n')),(0,r.kt)("p",null,"Run the main method of the ",(0,r.kt)("inlineCode",{parentName:"p"},"NervosDaoExample")," class by using gradle wrapper:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"CLICK ME"),(0,r.kt)("p",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ cd myDapp\n$ ./gradlew run --args=\"deposit\"\n> Task :run\nBefore depositing, balance: 602964 CKB\nNervos DAO deposit tx hash: 0xbc6acfb5f83620841157c25713afd2bccdd1451de0a3ab688b5010b4c30a1695\nAfter depositing, balance: 602964 CKB\n\nDeprecated Gradle features were used in this build, making it incompatible with Gradle 8.0.\nUse '--warning-mode all' to show the individual deprecation warnings.\nSee https://docs.gradle.org/7.0.2/userguide/command_line_interface.html#sec:command_line_warnings\n\nBUILD SUCCESSFUL in 1s\n2 actionable tasks: 1 executed, 1 up-to-date\n")))),(0,r.kt)("h2",{id:"transfer-ckb-to-a-multisig-address"},"Transfer CKB to a Multisig Address"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="ckb-sdk-java/example/src/main/java/org/nervos/ckb/SendToMultiSigAddressTxExample.java"',title:'"ckb-sdk-java/example/src/main/java/org/nervos/ckb/SendToMultiSigAddressTxExample.java"'},'package org.nervos.ckb;\n\nimport static org.nervos.ckb.utils.Const.*;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.nervos.ckb.crypto.secp256k1.Sign;\nimport org.nervos.ckb.indexer.*;\nimport org.nervos.ckb.service.Api;\nimport org.nervos.ckb.transaction.*;\nimport org.nervos.ckb.type.Witness;\nimport org.nervos.ckb.type.cell.CellOutput;\nimport org.nervos.ckb.utils.Utils;\n\n/** Copyright \xa9 2019 Nervos Foundation. All rights reserved. */\npublic class SendToMultiSigAddressTxExample {\n\n  private static Api api;\n  private static CkbIndexerApi ckbIndexerApi;\n  private static String MultiSigAddress = "ckt1qyqlqn8vsj7r0a5rvya76tey9jd2rdnca8lqh4kcuq";\n  private static String TestPrivateKey =\n      "d00c06bfd800d27397002dca6fb0993d5ba6399b4238b2f29ee9deb97593d2bc";\n  private static String TestAddress = "ckt1qyqvsv5240xeh85wvnau2eky8pwrhh4jr8ts8vyj37";\n\n  static {\n    api = new Api(NODE_URL, false);\n    ckbIndexerApi = new CkbIndexerApi(CKB_INDEXER_URL, false);\n  }\n\n  public static void main(String[] args) throws Exception {\n    List<Receiver> receivers =\n        Collections.singletonList(new Receiver(MultiSigAddress, Utils.ckbToShannon(20000)));\n    String changeAddress = "ckt1qyqvsv5240xeh85wvnau2eky8pwrhh4jr8ts8vyj37";\n\n    System.out.println("Before transferring, sender\'s balance: " + getBalance() + " CKB");\n\n    System.out.println(\n        "Before transferring, multi-sig address balance: " + getMultiSigBalance() + " CKB");\n\n    System.out.println("Before transferring, change address balance: " + getBalance() + " CKB");\n\n    String hash = sendCapacity(receivers, changeAddress);\n    System.out.println("Transaction hash: " + hash);\n\n    // waiting transaction into block, sometimes you should wait more seconds\n    Thread.sleep(30000);\n\n    System.out.println("After transferring, sender\'s address balance: " + getBalance() + " CKB");\n\n    System.out.println(\n        "After transferring, multi-sig address balance: " + getMultiSigBalance() + " CKB");\n\n    System.out.println("After transferring, change address balance: " + getBalance() + " CKB");\n  }\n\n  private static String getBalance() throws IOException {\n    return new IndexerCollector(api, ckbIndexerApi)\n        .getCapacity(TestAddress)\n        .divide(UnitCKB)\n        .toString(10);\n  }\n\n  private static String getMultiSigBalance() throws IOException {\n    return new IndexerCollector(api, ckbIndexerApi)\n        .getCapacity(MultiSigAddress)\n        .divide(UnitCKB)\n        .toString(10);\n  }\n\n  private static String sendCapacity(List<Receiver> receivers, String changeAddress)\n      throws IOException {\n    TransactionBuilder txBuilder = new TransactionBuilder(api);\n    IndexerCollector txUtils = new IndexerCollector(api, ckbIndexerApi);\n\n    List<CellOutput> cellOutputs = txUtils.generateOutputs(receivers, changeAddress);\n    txBuilder.addOutputs(cellOutputs);\n\n    List<ScriptGroupWithPrivateKeys> scriptGroupWithPrivateKeysList = new ArrayList<>();\n\n    // You can get fee rate by rpc or set a simple number\n    BigInteger feeRate = BigInteger.valueOf(1024);\n\n    // initial_length = 2 * secp256k1_signature_byte.length\n    CollectResult collectResult =\n        txUtils.collectInputs(\n            Collections.singletonList(TestAddress),\n            txBuilder.buildTx(),\n            feeRate,\n            Sign.SIGN_LENGTH * 2);\n\n    // update change cell output capacity after collecting cells\n    cellOutputs.get(cellOutputs.size() - 1).capacity = collectResult.changeCapacity;\n    txBuilder.setOutputs(cellOutputs);\n\n    int startIndex = 0;\n    for (CellsWithAddress cellsWithAddress : collectResult.cellsWithAddresses) {\n      txBuilder.addInputs(cellsWithAddress.inputs);\n      for (int i = 0; i < cellsWithAddress.inputs.size(); i++) {\n        txBuilder.addWitness(i == 0 ? new Witness(Witness.SIGNATURE_PLACEHOLDER) : "0x");\n      }\n      scriptGroupWithPrivateKeysList.add(\n          new ScriptGroupWithPrivateKeys(\n              new ScriptGroup(NumberUtils.regionToList(startIndex, cellsWithAddress.inputs.size())),\n              Collections.singletonList(TestPrivateKey)));\n    }\n\n    Secp256k1SighashAllBuilder signBuilder = new Secp256k1SighashAllBuilder(txBuilder.buildTx());\n\n    for (ScriptGroupWithPrivateKeys scriptGroupWithPrivateKeys : scriptGroupWithPrivateKeysList) {\n      signBuilder.sign(\n          scriptGroupWithPrivateKeys.scriptGroup, scriptGroupWithPrivateKeys.privateKeys.get(0));\n    }\n\n    return api.sendTransaction(signBuilder.buildTx());\n  }\n}\n')),(0,r.kt)("p",null,"Run the main method of the ",(0,r.kt)("inlineCode",{parentName:"p"},"SendToMultiSigAddressTxExample")," class by using gradle:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"CLICK ME"),(0,r.kt)("p",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ cd myDapp\n$ gradle run\n> Task :run\nBefore transferring, sender's balance: 20001406910 CKB\nBefore transferring, multi-sig address balance: 0 CKB\nBefore transferring, change address balance: 20001406910 CKB\nTransaction hash: 0x99340f20e59915c66dd802c7fe98c56e91728a1e1a9ba0b426c500472b7ba5d1\nAfter transferring, sender's address balance: 20002391844 CKB\nAfter transferring, multi-sig address balance: 20000 CKB\nAfter transferring, change address balance: 20002391844 CKB\n")))),(0,r.kt)("h2",{id:"transfer-ckb-to-multiple-receivers"},"Transfer CKB to Multiple Receivers"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="ckb-sdk-java/example/src/main/java/org/nervos/ckb/SingleSigWithCkbIndexerTxExample.java"',title:'"ckb-sdk-java/example/src/main/java/org/nervos/ckb/SingleSigWithCkbIndexerTxExample.java"'},'package org.nervos.ckb;\n\nimport static org.nervos.ckb.utils.Const.*;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport org.nervos.ckb.address.AddressUtils;\nimport org.nervos.ckb.address.Network;\nimport org.nervos.ckb.crypto.secp256k1.ECKeyPair;\nimport org.nervos.ckb.crypto.secp256k1.Sign;\nimport org.nervos.ckb.indexer.*;\nimport org.nervos.ckb.service.Api;\nimport org.nervos.ckb.transaction.*;\nimport org.nervos.ckb.type.Witness;\nimport org.nervos.ckb.type.cell.CellOutput;\nimport org.nervos.ckb.type.transaction.Transaction;\nimport org.nervos.ckb.utils.Numeric;\nimport org.nervos.ckb.utils.Utils;\n\n/** Copyright \xa9 2019 Nervos Foundation. All rights reserved. */\npublic class SingleSigWithCkbIndexerTxExample {\n\n  private static Api api;\n  private static CkbIndexerApi ckbIndexerApi;\n  private static List<String> SendPrivateKeys;\n  private static List<String> SendAddresses;\n  private static List<String> ReceiveAddresses;\n\n  static {\n    api = new Api(NODE_URL, false);\n    ckbIndexerApi = new CkbIndexerApi(CKB_INDEXER_URL, false);\n    SendPrivateKeys =\n        Arrays.asList("e79f3207ea4980b7fed79956d5934249ceac4751a4fae01a0f7c4a96884bc4e3");\n    SendAddresses = Arrays.asList("ckt1qyqrdsefa43s6m882pcj53m4gdnj4k440axqswmu83");\n    ReceiveAddresses =\n        Arrays.asList(\n            "ckt1qyqvsv5240xeh85wvnau2eky8pwrhh4jr8ts8vyj37",\n            "ckt1qyqtnz38fht9nvmrfdeunrhdtp29n0gagkps4duhek",\n            "ckt1qg8mxsu48mncexvxkzgaa7mz2g25uza4zpz062relhjmyuc52ps3zn47dugwyk5e6mgxvlf5ukx7k3uyq9wlkkmegke");\n  }\n\n  public static void main(String[] args) throws Exception {\n    AddressUtils utils = new AddressUtils(Network.TESTNET);\n    for (int i = 0; i < SendAddresses.size() - 1; i++) {\n      String testPublicKey = ECKeyPair.publicKeyFromPrivate(SendPrivateKeys.get(i));\n      String address = SendAddresses.get(i);\n      if (!address.equals(utils.generateFromPublicKey(testPublicKey))) {\n        System.out.println("Private key and address " + address + " are not matched");\n        return;\n      }\n    }\n\n    System.out.println("Wait some time for ckb-indexer running");\n\n    List<Receiver> receivers =\n        Arrays.asList(\n            new Receiver(ReceiveAddresses.get(0), Utils.ckbToShannon(200)),\n            new Receiver(ReceiveAddresses.get(1), Utils.ckbToShannon(200)),\n            new Receiver(ReceiveAddresses.get(2), Utils.ckbToShannon(300)));\n\n    System.out.println(\n        "Before transferring, first sender\'s balance: "\n            + getBalance(SendAddresses.get(0)).divide(UnitCKB).toString(10)\n            + " CKB");\n\n    String hash = sendCapacity(receivers, SendAddresses.get(0));\n    System.out.println("Transaction hash: " + hash);\n\n    // waiting transaction into block, sometimes you should wait more seconds\n    Thread.sleep(30000);\n\n    System.out.println(\n        "After transferring, first sender\'s balance: "\n            + getBalance(SendAddresses.get(0)).divide(UnitCKB).toString(10)\n            + " CKB");\n  }\n\n  private static BigInteger getBalance(String address) throws IOException {\n    return new IndexerCollector(api, ckbIndexerApi).getCapacity(address);\n  }\n\n  private static String sendCapacity(List<Receiver> receivers, String changeAddress)\n      throws IOException {\n    List<ScriptGroupWithPrivateKeys> scriptGroupWithPrivateKeysList = new ArrayList<>();\n\n    TransactionBuilder txBuilder = new TransactionBuilder(api);\n    IndexerCollector txUtils = new IndexerCollector(api, ckbIndexerApi);\n\n    List<CellOutput> cellOutputs = txUtils.generateOutputs(receivers, changeAddress);\n    txBuilder.addOutputs(cellOutputs);\n\n    // You can get fee rate by rpc or set a simple number\n    BigInteger feeRate = BigInteger.valueOf(1024);\n\n    // initial_length = 2 * secp256k1_signature_byte.length\n    // collectInputsWithIndexer method uses indexer rpc to collect cells quickly\n    CollectResult collectResult =\n        txUtils.collectInputs(SendAddresses, txBuilder.buildTx(), feeRate, Sign.SIGN_LENGTH * 2);\n\n    // update change cell output capacity after collecting cells if there is changeOutput\n    if (Numeric.toBigInt(collectResult.changeCapacity).compareTo(BigInteger.ZERO) > 0) {\n      cellOutputs.get(cellOutputs.size() - 1).capacity = collectResult.changeCapacity;\n      txBuilder.setOutputs(cellOutputs);\n    }\n\n    int startIndex = 0;\n    for (CellsWithAddress cellsWithAddress : collectResult.cellsWithAddresses) {\n      txBuilder.addInputs(cellsWithAddress.inputs);\n      for (int i = 0; i < cellsWithAddress.inputs.size(); i++) {\n        txBuilder.addWitness(i == 0 ? new Witness(Witness.SIGNATURE_PLACEHOLDER) : "0x");\n      }\n      if (cellsWithAddress.inputs.size() > 0) {\n        scriptGroupWithPrivateKeysList.add(\n            new ScriptGroupWithPrivateKeys(\n                new ScriptGroup(\n                    NumberUtils.regionToList(startIndex, cellsWithAddress.inputs.size())),\n                Collections.singletonList(\n                    SendPrivateKeys.get(SendAddresses.indexOf(cellsWithAddress.address)))));\n        startIndex += cellsWithAddress.inputs.size();\n      }\n    }\n\n    Secp256k1SighashAllBuilder signBuilder = new Secp256k1SighashAllBuilder(txBuilder.buildTx());\n\n    for (ScriptGroupWithPrivateKeys scriptGroupWithPrivateKeys : scriptGroupWithPrivateKeysList) {\n      signBuilder.sign(\n          scriptGroupWithPrivateKeys.scriptGroup, scriptGroupWithPrivateKeys.privateKeys.get(0));\n    }\n    Transaction tx = signBuilder.buildTx();\n    return api.sendTransaction(tx);\n  }\n}\n')),(0,r.kt)("p",null,"Run the main method of the ",(0,r.kt)("inlineCode",{parentName:"p"},"SingleSigWithCkbIndexerTxExample")," class by using gradle:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"CLICK ME"),(0,r.kt)("p",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ cd myDapp\n$ gradle run\n> Task :run\nBefore transferring, sender's balance: 20001406910 CKB\nBefore transferring, multi-sig address balance: 0 CKB\nBefore transferring, change address balance: 20001406910 CKB\nTransaction hash: 0x99340f20e59915c66dd802c7fe98c56e91728a1e1a9ba0b426c500472b7ba5d1\nAfter transferring, sender's address balance: 20002391844 CKB\nAfter transferring, multi-sig address balance: 20000 CKB\nAfter transferring, change address balance: 20002391844 CKB\n")))),(0,r.kt)("h2",{id:"transfer-all-balance"},"Transfer all Balance"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="ckb-sdk-java/example/src/main/java/org/nervos/ckb/TransferAllBalanceWithCkbIndexerExample.java"',title:'"ckb-sdk-java/example/src/main/java/org/nervos/ckb/TransferAllBalanceWithCkbIndexerExample.java"'},'package org.nervos.ckb;\n\nimport static org.nervos.ckb.utils.Const.*;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.nervos.ckb.address.AddressUtils;\nimport org.nervos.ckb.address.Network;\nimport org.nervos.ckb.crypto.secp256k1.ECKeyPair;\nimport org.nervos.ckb.crypto.secp256k1.Sign;\nimport org.nervos.ckb.indexer.*;\nimport org.nervos.ckb.service.Api;\nimport org.nervos.ckb.transaction.*;\nimport org.nervos.ckb.type.Witness;\nimport org.nervos.ckb.type.cell.CellOutput;\nimport org.nervos.ckb.type.transaction.Transaction;\nimport org.nervos.ckb.utils.Numeric;\nimport org.nervos.ckb.utils.Utils;\n\n/** Copyright \xa9 2019 Nervos Foundation. All rights reserved. */\npublic class TransferAllBalanceWithCkbIndexerExample {\n\n  private static Api api;\n  private static CkbIndexerApi ckbIndexerApi;\n  private static List<String> SendPrivateKeys;\n  private static List<String> SendAddresses;\n  private static List<String> ReceiveAddresses;\n\n  static {\n    api = new Api(NODE_URL, false);\n    ckbIndexerApi = new CkbIndexerApi(CKB_INDEXER_URL, false);\n    SendPrivateKeys =\n        Collections.singletonList(\n            "d00c06bfd800d27397002dca6fb0993d5ba6399b4238b2f29ee9deb97593d2bc");\n    SendAddresses = Collections.singletonList("ckt1qyqvsv5240xeh85wvnau2eky8pwrhh4jr8ts8vyj37");\n    ReceiveAddresses = Collections.singletonList("ckt1qyqxvnycu7tdtyuejn3mmcnl4y09muxz8c3s2ewjd4");\n  }\n\n  public static void main(String[] args) throws Exception {\n    AddressUtils utils = new AddressUtils(Network.TESTNET);\n    for (int i = 0; i < SendAddresses.size() - 1; i++) {\n      String testPublicKey = ECKeyPair.publicKeyFromPrivate(SendPrivateKeys.get(i));\n      String address = SendAddresses.get(i);\n      if (!address.equals(utils.generateFromPublicKey(testPublicKey))) {\n        System.out.println("Private key and address " + address + " are not matched");\n        return;\n      }\n    }\n\n    System.out.println("Wait some time for ckb-indexer running");\n\n    List<Receiver> receivers =\n        Collections.singletonList(new Receiver(ReceiveAddresses.get(0), Utils.ckbToShannon(100)));\n\n    System.out.println(\n        "Before transferring, first sender\'s balance: "\n            + getBalance(SendAddresses.get(0)).divide(UnitCKB).toString(10)\n            + " CKB");\n\n    // For transferring all balance, change address is set to be null\n    // Because the transfer of the entire balance will not set the change cell, you need to\n    // carefully calculate the transfer amount\n    String hash = sendCapacity(receivers, null);\n    System.out.println("Transaction hash: " + hash);\n\n    // waiting transaction into block, sometimes you should wait more seconds\n    Thread.sleep(30000);\n\n    System.out.println(\n        "After transferring, first sender\'s balance: "\n            + getBalance(SendAddresses.get(0)).divide(UnitCKB).toString(10)\n            + " CKB");\n  }\n\n  private static BigInteger getBalance(String address) throws IOException {\n    return new IndexerCollector(api, ckbIndexerApi).getCapacity(address);\n  }\n\n  private static String sendCapacity(List<Receiver> receivers, String changeAddress)\n      throws IOException {\n    List<ScriptGroupWithPrivateKeys> scriptGroupWithPrivateKeysList = new ArrayList<>();\n\n    TransactionBuilder txBuilder = new TransactionBuilder(api);\n    IndexerCollector txUtils = new IndexerCollector(api, ckbIndexerApi);\n\n    List<CellOutput> cellOutputs = txUtils.generateOutputs(receivers, changeAddress);\n    txBuilder.addOutputs(cellOutputs);\n\n    // You can get fee rate by rpc or set a simple number\n    BigInteger feeRate = BigInteger.valueOf(1024);\n\n    // initial_length = 2 * secp256k1_signature_byte.length\n    // collectInputsWithIndexer method uses indexer rpc to collect cells quickly\n    CollectResult collectResult =\n        txUtils.collectInputs(SendAddresses, txBuilder.buildTx(), feeRate, Sign.SIGN_LENGTH * 2);\n\n    // update change cell output capacity after collecting cells if there is changeOutput\n    if (Numeric.toBigInt(collectResult.changeCapacity).compareTo(BigInteger.ZERO) > 0) {\n      cellOutputs.get(cellOutputs.size() - 1).capacity = collectResult.changeCapacity;\n      txBuilder.setOutputs(cellOutputs);\n    }\n\n    int startIndex = 0;\n    for (CellsWithAddress cellsWithAddress : collectResult.cellsWithAddresses) {\n      txBuilder.addInputs(cellsWithAddress.inputs);\n      for (int i = 0; i < cellsWithAddress.inputs.size(); i++) {\n        txBuilder.addWitness(i == 0 ? new Witness(Witness.SIGNATURE_PLACEHOLDER) : "0x");\n      }\n      if (cellsWithAddress.inputs.size() > 0) {\n        scriptGroupWithPrivateKeysList.add(\n            new ScriptGroupWithPrivateKeys(\n                new ScriptGroup(\n                    NumberUtils.regionToList(startIndex, cellsWithAddress.inputs.size())),\n                Collections.singletonList(\n                    SendPrivateKeys.get(SendAddresses.indexOf(cellsWithAddress.address)))));\n        startIndex += cellsWithAddress.inputs.size();\n      }\n    }\n\n    Secp256k1SighashAllBuilder signBuilder = new Secp256k1SighashAllBuilder(txBuilder.buildTx());\n\n    for (ScriptGroupWithPrivateKeys scriptGroupWithPrivateKeys : scriptGroupWithPrivateKeysList) {\n      signBuilder.sign(\n          scriptGroupWithPrivateKeys.scriptGroup, scriptGroupWithPrivateKeys.privateKeys.get(0));\n    }\n    Transaction tx = signBuilder.buildTx();\n    return api.sendTransaction(tx);\n  }\n}\n')),(0,r.kt)("p",null,"Run the main method of the ",(0,r.kt)("inlineCode",{parentName:"p"},"TransferAllBalanceWithCkbIndexerExample")," class by using gradle:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"CLICK ME"),(0,r.kt)("p",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ cd myDapp\n$ gradle run\n> Task :run\nWait some time for ckb-indexer running\nBefore transferring, first sender's balance: 20005808806 CKB\nTransaction hash: 0x7fd0a39a559c4d3c7043849365e58b82ed3d4bdf8b3344fa2fdf3ea18c7fd098\nAfter transferring, first sender's balance: 20005607818 CKB\n")))))}p.isMDXComponent=!0}}]);